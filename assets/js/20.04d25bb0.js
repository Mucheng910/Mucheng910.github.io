(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{217:function(e,t,a){"use strict";a.r(t);var r=a(0),v=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"前端性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端性能优化","aria-hidden":"true"}},[e._v("#")]),e._v(" 前端性能优化")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://github.com/Mucheng910/image/blob/master/js%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.png?raw=true",alt:"屏幕快照 2019-08-09 上午10.24.13"}})]),e._v(" "),a("h2",{attrs:{id:"前端seo优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端seo优化","aria-hidden":"true"}},[e._v("#")]),e._v(" 前端SEO优化")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("*<head>*")]),a("em",[e._v("标签放网页的标题，各个页面不同。")])]),e._v(" "),a("li",[a("code",[e._v("*<meta keywords>*")]),a("em",[e._v("列举出几个重要的关键词。")])]),e._v(" "),a("li",[a("code",[e._v("*<meta description>*")]),a("em",[e._v("网页内容的高度概括。")])]),e._v(" "),a("li",[a("code",[e._v("*<br />*")]),a("em",[e._v("标记应该放在文本中间，即使用")]),a("code",[e._v("*<p><br /></p>*")]),a("em",[e._v("替代突兀的")]),a("code",[e._v("*<br />*")]),a("em",[e._v("标记。")])]),e._v(" "),a("li",[a("em",[e._v("html语义化。例如我们要做一个导航，可以使用")]),a("code",[e._v("*div*")]),a("em",[e._v("+")]),a("code",[e._v("*span*")]),a("em",[e._v("标记：")])]),e._v(" "),a("li",[a("code",[e._v("img alt")]),e._v("其实搜索引擎在分析页面的时候，也会根据这个词去判断图片的内容")])]),e._v(" "),a("p",[a("em",[e._v("有了nodejs后主流做法是前后端同构方案，即一套代码在浏览器端和node端都可以运行，从而可以先在node端请求数据渲染模板，然后将渲染结果返回给浏览器最终呈现，是目前最完美的前后端分离+SEO解决方案，目测没有之一")])])])}),[],!1,null,null,null);t.default=v.exports}}]);