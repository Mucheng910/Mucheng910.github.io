(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{212:function(e,t,r){"use strict";r.r(t);var a=r(0),d=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"redux-系列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redux-系列","aria-hidden":"true"}},[e._v("#")]),e._v(" Redux 系列")]),e._v(" "),r("h2",{attrs:{id:"在mvc的设计模式下理解react-redux"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#在mvc的设计模式下理解react-redux","aria-hidden":"true"}},[e._v("#")]),e._v(" 在MVC的设计模式下理解react-redux")]),e._v(" "),r("p",[e._v("MVC（Model-View-Controller）的三个角色其实是各司其职：")]),e._v(" "),r("ul",[r("li",[e._v("model持有UI要展现的数据")]),e._v(" "),r("li",[e._v("View即UI的展现")]),e._v(" "),r("li",[e._v("Controller用于控制\n以React来说，它就应该只专注于View的呈现，并将这些展现元素封装为Component。这些Component要展现的props可以视为Model所持有的数据。\nReact扮演的是View的角色，Redux则是Controller，至于Model就是Redux Store中存储的State\n执行"),r("code",[e._v("action")]),e._v("的目的虽然是修改"),r("code",[e._v("Model")]),e._v("，不过在Redux中，我们尽量希望遵循FP的思想设计出所谓的“纯函数”，于是Redux就引入了"),r("code",[e._v("reducer")]),e._v("函数，这个函数要做的事情其实就是对"),r("code",[e._v("Model")]),e._v("进行"),r("code",[e._v("transform")]),e._v("（可以考虑引入immutable.js来存储和操作Modle）。一旦"),r("code",[e._v("Model")]),e._v("对象发生了变化（并不是真正发生了变化，而是产生了一个新的Model），Redux就会通知React Component根据新获得的"),r("code",[e._v("Model")]),e._v("去重新Render。")])]),e._v(" "),r("p",[e._v("概况下来，React+Redux的主体流程为：")]),e._v(" "),r("ul",[r("li",[e._v("通过action获得model，并将其作为state存储到Store中；")]),e._v(" "),r("li",[e._v("传递给React Component，按照某种设计呈现model数据；")]),e._v(" "),r("li",[e._v("调用action发起update请求，从而调用reducer生成新的state存储到Store中；")]),e._v(" "),r("li",[e._v("redux通知React Component重新Render。")])]),e._v(" "),r("h2",{attrs:{id:"redux-异步处理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redux-异步处理","aria-hidden":"true"}},[e._v("#")]),e._v(" redux 异步处理")]),e._v(" "),r("p",[r("em",[e._v("redux-thunk 中间件就能够在 action 传递给 reducer 前进行处理。")])]),e._v(" "),r("h2",{attrs:{id:"redux的优缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redux的优缺点","aria-hidden":"true"}},[e._v("#")]),e._v(" redux的优缺点")]),e._v(" "),r("p",[r("strong",[e._v("缺点！！")])]),e._v(" "),r("ul",[r("li",[e._v("Redux 带来了函数式编程、不可变性思想等等，为了配合这些理念，开发者必须要写很多“模式代码（boilerplate）”，繁琐以及重复是开发者不愿意容忍的。当然也有很多 hack 旨在减少 boilerplate，但目前阶段，可以说 Redux 天生就附着繁琐；")]),e._v(" "),r("li",[e._v("使用 Redux，那么你的应用就要用 objects 或者 arrays 描述状态；OMG！")]),e._v(" "),r("li",[e._v("使用 Redux，那么你的应用就要使用 plain objects 即 actions ，来描述变化；OMG！")]),e._v(" "),r("li",[e._v("使用 Redux，那么你的应用就要使用纯函数去处理变化；OMG！")]),e._v(" "),r("li",[e._v("应用中，状态很多都要抽象到 store，那么何时使用 local states 何时接入 Redux store？")]),e._v(" "),r("li",[e._v("不能痛痛快快地写业务，一个变化就要对应编写 action（action creator），reducer 等等；")]),e._v(" "),r("li",[e._v("和响应式结合函数式的 Mobx 相比，编程体验“打折扣”")]),e._v(" "),r("li",[e._v("Redux 可以理解为一个简易的发布订阅系统。那么因此带来的内存消费也许会大一丢丢。")])]),e._v(" "),r("p",[r("strong",[e._v("优点！！！")])]),e._v(" "),r("ul",[r("li",[e._v("便于调试，具体不再展开；")]),e._v(" "),r("li",[e._v("便于线上错误收集，只需要发送 states, actions 等快照即可；")]),e._v(" "),r("li",[e._v("结合 localStorage 初始化 store；")]),e._v(" "),r("li",[e._v("便于服务端渲染；")]),e._v(" "),r("li",[e._v("开发在线协作型应用的救命解药；")]),e._v(" "),r("li",[e._v("时光旅行 Undo／Redo；")]),e._v(" "),r("li",[e._v("便于测试")])]),e._v(" "),r("h2",{attrs:{id:"react-redux-和-redux-的工作流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-redux-和-redux-的工作流程","aria-hidden":"true"}},[e._v("#")]),e._v(" React-Redux 和 Redux 的工作流程")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://github.com/Mucheng910/image/blob/master/react-redux%E8%BF%87%E7%A8%8B%E5%9B%BE.png?raw=true",alt:"屏幕快照 2019-08-08 下午9.44.30"}})]),e._v(" "),r("h2",{attrs:{id:"redux-源码解析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redux-源码解析","aria-hidden":"true"}},[e._v("#")]),e._v(" Redux 源码解析")])])}),[],!1,null,null,null);t.default=d.exports}}]);